#include "stdafx.h"
#include "PhysicsEngine.h"

float currentDT;

PhysicsEngine::PhysicsEngine()
{

}


PhysicsEngine::~PhysicsEngine()
{

}

void PhysicsEngine::updatePhysics(float deltaTime, std::vector<Entity*>* entities, std::vector<Tile*>* tiles) {
	collisions.clear();

	currentDT = deltaTime;

	//Broad Phase

	for (int i = 0; i < entities->size(); i++) {
		for (int j = 0; j < tiles->size(); j++) {
			if (tiles->at(j) == NULL) continue;
			float r1 = entities->at(i)->radius;	
			float r2 = tiles->at(j)->radius;

			if (/*Distance(entities->at(i)->origin, tiles->at(j)->origin) <= r1 + r2*/true) {
				bodyPair pair;
				//std::cout << "AAA" << std::endl;
				pair.A = (RigidBody*)entities->at(i);
				pair.B = (RigidBody*)tiles->at(j);
				collisions.push_back(pair);
			}
		}
	}

	for (int i = 0; i < entities->size() - 1; i++) {
		for (int j = 1; j < entities->size(); j++) {
			float r1 = entities->at(i)->radius;
			float r2 = entities->at(j)->radius;

			if (Distance(entities->at(i)->origin, entities->at(j)->origin) <= r1 + r2) {
				bodyPair pair;
				pair.A = (RigidBody*)entities->at(i);
				pair.B = (RigidBody*)entities->at(j);
				collisions.push_back(pair);
			}
		}
	}
	
	//integrate force

	for (auto b : *entities) {
		//integrateForces(b, deltaTime);
	}

	//solve collisions

	for (auto b : collisions) {
		polygonToPolygon(&b);
	}

	//apply obj gravity
	//for (auto e : *entities) {
	//	for (auto t : *tiles) {
	//		if (t == NULL) continue;
	//		if (Distance(e->origin, t->origin) < TILE_SIZE + e->getRadius()) {
	//			Vector2f gravity = 150000*(1 / Distance(e->origin, t->origin))*normalize(e->origin - t->origin);
	//			if (magnitude(gravity) > 1) {
	//				//std::cout << gravity.x << " " << gravity.y << std::endl;
	//			}
	//			e->force -= gravity;
	//		}
	//	}
	//}

	//integrate velocity

	for (auto b : *entities) {
		integrateVelocity(b, deltaTime);
	}

	//correct positions
	for (auto b : collisions) {
		//positionalCorrection(&b);
	}

	//zero forces

	for (auto b : *entities) {
		b->force = Vector2f(0, 0);
		b->impulse = Vector2f(0, 0);
	}

	for (auto b : *tiles) {
		if (b == NULL) continue;
		b->force = Vector2f(0, 0);
		b->impulse = Vector2f(0, 0);
	}

	for (auto e : *entities) {
		sf::FloatRect AABB = e->getAABB();
		if (AABB.top + AABB.height > 1920 * 3) {
			e->origin.y = 1920 * 3 - e->dimensions.y / 2;
			e->velocity.y = -100;
		}

		if (AABB.top < 0) {
			e->origin.y = 0 + e->dimensions.y / 2;
			e->velocity.y = 100;
		}

		if (AABB.left + AABB.width > 1920 * 3) {
			e->origin.x = 1920 * 3 - e->dimensions.x / 2;
			e->velocity.x = -100;
		}

		if (AABB.left < 0) {
			e->origin.x = 0 + e->dimensions.x / 2;
			e->velocity.x = 100;
		}

	}
	
}

std::vector<Entity*> PhysicsEngine::queryAABB(FloatRect query, std::vector<Entity*>* entities) {

	std::vector<Entity*> results;

	for (auto e : *entities) {
		if (query.intersects(e->getAABB())) {
			results.push_back(e);
		}
	}

	return results;
}


bool PhysicsEngine::queryPlayerAABB(FloatRect query, Player* player) {
	if (query.intersects(player->getAABB())) return true;
	return false;
}

void integrateForces(RigidBody* b, float deltaTime)
{
	if (b->massInv == 0.0f) {
		return;
	}


	b->velocity += (rotateVec(b->force, -b->angle) + b->gravity);

	//b->velocity += (rotateVec(b->force, -b->angle) * b->massInv + b->gravity + b->impulse) * (deltaTime / 2.0f);
	//b->velocity += (b->force * b->massInv + b->gravity) * (1.0f / 2.0f);
	//b->velocity += b->force;// +b->gravity;
}

void integrateVelocity(RigidBody* b, float deltaTime)
{
	if (b->massInv == 0.0f) {
		return;
	}

	b->airTime--;
	if (b->airTime < 0) {
		b->airTime = 0;
		b->angle = 0;
	}

	//if (b->airTime > 0) {
	//	b->force.y += 100000;
	//}
	//if(abs(magnitude(b->velocity)) > 1) {
		b->velocity += (rotateVec(b->force, -b->angle) + b->gravity);
		b->origin += b->velocity;
		//b->origin += b->velocity * deltaTime;
	//}


	//b->origin += b->velocity;

	//if (abs(b->velocity.y) > 1) {
	//	if (b->velocity.y > 0 || b->velocity.y < -3) {
	//		b->origin.y += b->velocity.y;
	//	}
	//	else {
	//		b->velocity.y = 0;
	//	}
	//}

	//if (abs(b->velocity.x) > 1) {
	//	b->origin.x += b->velocity.x;
	//}

	//integrateForces(b, deltaTime);
}

//void polygonToPolygon(bodyPair* pair)
//{
//
//	//if (pair->A->getAABB().intersects(pair->B->getAABB())) {
//	//	std::cout << "WTF" << std::endl;
//	//}
//
//	if (pair->B->body->vertexCount == 3 && pair->A->getAABB().intersects(pair->B->getAABB())) {
//		std::cout << "AAA" << std::endl;
//	}
//
//	//float penetration;
//	//Vector2f normal;
//
//	RigidBody* A = pair->A;
//	RigidBody* B = pair->B;
//
//	// Check for a separating axis with A's face planes
//	int faceA;
//	float penetrationA = FindAxisLeastPenetration(&faceA, A->body, B->body);
//	if (penetrationA >= 0.0f)
//		return;
//
//	// Check for a separating axis with B's face planes
//	int faceB;
//	float penetrationB = FindAxisLeastPenetration(&faceB, B->body, A->body);
//	if (penetrationB >= 0.0f)
//		return;
//
//	int referenceIndex;
//	bool flip; // Always point from a to b
//
//	RigidBody *RefPoly; // Reference
//	RigidBody *IncPoly; // Incident
//
//	if (BiasGreaterThan(penetrationA, penetrationB))
//	{
//		RefPoly = A;
//		IncPoly = B;
//		referenceIndex = faceA;
//		flip = false;
//	}
//
//	else
//	{
//		RefPoly = B;
//		IncPoly = A;
//		referenceIndex = faceB;
//		flip = true;
//	}
//
//	Vector2f incidentFace[2];
//	FindIncidentFace(incidentFace, RefPoly, IncPoly, referenceIndex);
//
//// Setup reference face vertices
//
//
//	Vector2f v1 = RefPoly->body->vertices[referenceIndex];
//	referenceIndex = referenceIndex + 1 == RefPoly->body->vertexCount ? 0 : referenceIndex + 1;
//	Vector2f v2 = RefPoly->body->vertices[referenceIndex];
//
//	// Transform vertices to world space
//	//v1 = RefPoly->u * v1 + RefPoly->body->position;
//	//v2 = RefPoly->u * v2 + RefPoly->body->position;
//
//	// Calculate reference face side normal in world space
//	//Vector2f sidePlaneNormal = Vector2f(v2.x - v1.x, v2.y - v1.y);
//	Vector2f sidePlaneNormal = v2 - v1;
//	sidePlaneNormal = normalize(sidePlaneNormal);
//
//	// Orthogonalize
//	Vector2f refFaceNormal(sidePlaneNormal.y, -sidePlaneNormal.x);
//
//	// ax + by = c
//	// c is distance from origin
//	float refC = dotProduct(refFaceNormal, v1);
//	float negSide = -dotProduct(sidePlaneNormal, v1);
//	float posSide = dotProduct(sidePlaneNormal, v2);
//
//	// Clip incident face to reference face side planes
//	if (Clip(-sidePlaneNormal, negSide, incidentFace) < 2)
//		return; // Due to floating point error, possible to not have required points
//
//	if (Clip(sidePlaneNormal, posSide, incidentFace) < 2)
//		return; // Due to floating point error, possible to not have required points
//
//	// Flip
//	//pair->normal = flip ? Vector2f(refFaceNormal.x, refFaceNormal.y) : Vector2f(-refFaceNormal.x, -refFaceNormal.y);
//	pair->normal = flip ? refFaceNormal : -refFaceNormal;
//
//	// Keep points behind reference face
//	int cp = 0; // clipped points behind reference face
//	float separation = dotProduct(refFaceNormal, incidentFace[0]) - refC;
//	if (separation <= 0.0f)
//	{
//		//m->contacts[cp] = incidentFace[0];
//		pair->penetration = -separation;
//		++cp;
//	}
//	else {
//		pair->penetration = 0;
//	}
//
//	separation = dotProduct(refFaceNormal, incidentFace[1]) - refC;
//	if (separation <= 0.0f)
//	{
//		//m->contacts[cp] = incidentFace[1];
//
//		pair->penetration += -separation;
//		++cp;
//
//		// Average penetration
//		pair->penetration /= (float)cp;
//	}
//
//	//m->contact_count = cp;
//
//	//pair->normal = - pair->normal;
//
//	//std::cout << pair->penetration << std::endl;
//
//	resolveCollision(pair);
//
//
//}


void polygonToPolygon(bodyPair* pair) {
	int edgeCountA = pair->A->body->vertexCount;
	int edgeCountB = pair->B->body->vertexCount;

	RigidBody* A = pair->A;
	RigidBody* B = pair->B;

	float minIntervalDistance = FLT_MAX;
	Vector2f translationAxis;

	Vector2f normal;

	if (pair->A->getAABB().intersects(pair->B->getAABB())) {
		//std::cout << "WTF" << std::endl;
	}

	// Loop through all the edges of both polygons
	for (int i = 0; i < edgeCountA + edgeCountB; i++) {
		if (i < edgeCountA) {
			normal = A->body->normals[i];
		}
		else {
			normal = B->body->normals[i - edgeCountA];
		}

		// ===== 1. Find if the polygons are currently intersecting =====


		// Find the projection of the polygon on the current axis
		Vector2f projA = projectPolygon(normal, A->body);
		Vector2f projB = projectPolygon(normal, B->body);

		float intervalDistance = IntervalDistance(projA, projB);

		if (intervalDistance > 0) {
			//Polygons not intersecting (early out)
			return;
		}

		// Check if the current interval distance is the minimum one. If so store
		// the interval distance and the current distance.
		// This will be used to calculate the minimum translation vector
		intervalDistance = abs(intervalDistance);
		if (intervalDistance < minIntervalDistance) {
			minIntervalDistance = intervalDistance;
			translationAxis = normal;

			Vector2f d = A->origin - B->origin;
			if (dotProduct(d, translationAxis) < 0) {
				translationAxis = -translationAxis;
			}
		}
	}

	pair->normal = translationAxis;
	pair->penetration = minIntervalDistance;
	//pair->A->velocity += translationAxis * minIntervalDistance;
	//pair->B->velocity -= translationAxis * minIntervalDistance;
	pair->A->origin += pair->normal*pair->penetration;

	//if (dotProduct(Vector2f(cos(pair->A->angle), sin(pair->A->angle)), pair->normal) < -0.9) {
	//	std::cout << "AAA" << std::endl;
	//	return;
	//}

	resolveTileCollision(pair);

}

void resolveTileCollision(bodyPair* pair) {

	RigidBody* A = pair->A;
	RigidBody* B = pair->B;

	//Vector2f smallestVec = pair->penetration*pair->normal;

	//A->origin += smallestVec;
	////A->velocity += pair->penetration*pair->normal / (currentDT != 0 ? currentDT*2 : 1);
	//if (abs(A->velocity.x) <= abs(smallestVec.x)) {
	//	A->velocity.x = 0;
	//	smallestVec.x = 0;
	//}

	//if (abs(A->velocity.y) <= abs(smallestVec.y)) {
	//	A->velocity.y = 0;
	//	smallestVec.y = 0;
	//}
	//A->velocity += smallestVec;
	

	if (pair->normal.y > 0) {
		//pair->A->velocity.y = 0;
		std::cout << "CCC" << std::endl;
		pair->A->velocity.y = 1;
	}
	else {

		if (pair->normal.y < 0) {
			std::cout << "BBB" << std::endl;
			pair->A->velocity.y = 0;
		}
		else {
			std::cout << "AAA" << std::endl;
			pair->A->velocity.x = -pair->A->velocity.x * 0.1;
		}
	}


	//Extra stuff after adjustment

	if (pair->B->massInv == 0 && pair->normal.y < 0) {

		//	pair->A->force += pair->normal * 100.0f;

		float lastAngle = A->angle;
		float tryAngle = acos(dotProduct(pair->normal, Vector2f(0, -1)));
		if (abs(lastAngle - 90) > abs(tryAngle - 90)) {
			A->angle = tryAngle;
		}



		if (lastAngle != A->angle) {

			std::cout << A->angle * 180 / 3.1415926535 << std::endl;

			//std::cout << "Velocity goes from" << A->velocity.x << " " << A->velocity.y;
			A->velocity = Vector2f(A->velocity.x * cos(A->angle) - A->velocity.y * sin(A->angle), A->velocity.x * sin(A->angle) + A->velocity.y * cos(A->angle));
			//A->force = Vector2f(A->force.x * cos(A->angle) - A->force.y * sin(A->angle), A->force.x * sin(A->angle) + A->force.y * cos(A->angle));
			//std::cout << " to" << A->velocity.x << " " << A->velocity.y << std::endl;
		}

		if (pair->A->airTime <= 0) {
			pair->A->airTime = 2;
			return;
		}
		else {
			pair->A->airTime = 2;
		}
	}

	if (pair->B->massInv != 0 || pair->A->airTime <= 0) {
		return;
	}


}

void resolveCollision(bodyPair* pair) {
	RigidBody* A = pair->A;
	RigidBody* B = pair->B;

	// Calculate relative velocity
	Vector2f reletiveVelocity = B->velocity - A->velocity;


	// Calculate relative velocity in terms of the normal direction
	float velAlongNormal = dotProduct(reletiveVelocity, pair->normal);

	// Do not resolve if velocities are separating
	if (-velAlongNormal > 0) //should be  a >, but works with < (vel should be positive)
		return;

	// Calculate restitution
	float e = std::min(A->restitution, B->restitution);

	// Calculate impulse scalar
	float j = -(1 + A->restitution) * velAlongNormal;
	float i = -(1 + B->restitution) * velAlongNormal;
	j /= A->massInv + B->massInv;
	i /= A->massInv + B->massInv;

	// Apply impulse
	Vector2f impulse(j * pair->normal.x, j * pair->normal.y);
	Vector2f impulseb(i * pair->normal.x, i * pair->normal.y);

	A->velocity -= A->massInv * impulse;
	B->velocity += B->massInv * impulseb;

	//A->force -= impulse;
	//B->force += impulseb;

	//A->impulse -= impulse * 2.0f;
	//B->impulse += impulseb;



	//A->origin += pair->normal * pair->penetration;

	positionalCorrection(pair);

	/*if (pair->normal.y != 0) {

		float mu = Average(A->dynamicFriction, B->dynamicFriction);

		A->force -= Vector2f(mu * A->velocity.x / 100, 0);
		B->force += Vector2f(mu * B->velocity.x / 100, 0);
	}

	if (pair->B->massInv == 0 && pair->normal.y < 0) {
		pair->A->airTime = 5;
	}

	return;*/

	//calculate friction



	//std::cout << pair->A->airTime << std::endl;

	//if (pair->B->massInv == 0 && pair->normal.y < 0) {
	//	
	////	pair->A->force += pair->normal * 100.0f;

	//	float lastAngle = A->angle;
	//	float tryAngle = acos(dotProduct(pair->normal, Vector2f(0, -1)));
	//	if (abs(lastAngle - 90) > abs(tryAngle - 90)) {
	//		A->angle = tryAngle;
	//	}



	//	if (lastAngle != A->angle) {

	//		std::cout << A->angle * 180 / 3.1415926535 << std::endl;

	//		//std::cout << "Velocity goes from" << A->velocity.x << " " << A->velocity.y;
	//		A->velocity = Vector2f(A->velocity.x * cos(A->angle) - A->velocity.y * sin(A->angle), A->velocity.x * sin(A->angle) + A->velocity.y * cos(A->angle));
	//		//A->force = Vector2f(A->force.x * cos(A->angle) - A->force.y * sin(A->angle), A->force.x * sin(A->angle) + A->force.y * cos(A->angle));
	//		//std::cout << " to" << A->velocity.x << " " << A->velocity.y << std::endl;
	//	}

	//	if (pair->A->airTime <= 0) {
	//		pair->A->airTime = 2;
	//		return;
	//	}
	//	else {
	//		pair->A->airTime = 2;
	//	}
	//}

	//if (pair->B->massInv != 0 || pair->A->airTime <= 0) {
	//	return;
	//}

	return;

	//reletiveVelocity = B->velocity - A->velocity;
	reletiveVelocity = B->velocity - A->velocity;
	//if (abs(magnitude(reletiveVelocity)) == 0) return;
	Vector2f tangent = reletiveVelocity - dotProduct(reletiveVelocity, pair->normal) * pair->normal;
	tangent = normalize(tangent);

	//impulse = magnitude(impulse)*tangent*A->dynamicFriction;
	//impulseb = magnitude(impulseb)*tangent*B->dynamicFriction;

	//if (abs(impulse.x) > abs(A->velocity.x)) {
	//	impulse.x = -A->velocity.x;
	//}

	//if (abs(impulseb.x) > abs(B->velocity.x)) {
	//	impulseb.x = -B->velocity.x;
	//}

	//A->velocity += A->massInv * (impulse);
	//B->velocity -= B->massInv * (impulseb);

	float jt = -dotProduct(reletiveVelocity, tangent);
	jt = jt / (A->massInv + B->massInv);

	float mu = Average(A->staticFriction, B->staticFriction);
	Vector2f frictionimpulse;
	Vector2f frictionimpulseb;

	if (jt == 0) {
		return;
	}

	if (/*abs(jt) < j * mu*/false)
		//frictionimpulse = vec2d(jt * tangent.x, jt * tangent.y);
		frictionimpulse = jt * tangent;
	else
	{
		float dynamicfriction = Average(A->dynamicFriction, B->dynamicFriction);
		//frictionimpulse = vec2d(j * tangent.x * dynamicfriction, j * tangent.y * dynamicfriction);
		frictionimpulse = j * tangent * dynamicfriction;
	}

	if (/*abs(jt) < i * mu*/false)
		//frictionimpulseb = vec2d(jt * tangent.x, jt * tangent.y);
		frictionimpulseb = jt * tangent;
	else
	{
		float dynamicfriction = Average(A->dynamicFriction, B->dynamicFriction);
		//frictionimpulseb = vec2d(i * tangent.x * dynamicfriction, i * tangent.y * dynamicfriction);
		frictionimpulseb = i * tangent * dynamicfriction;
	}


	// apply

	//a->velocity.x -= a->massinv * frictionimpulse.x;
	//a->velocity.y -= a->massinv * frictionimpulse.y;
	//b->velocity.x += b->massinv * frictionimpulseb.x;
	//b->velocity.y += b->massinv * frictionimpulseb.y

	//std::cout << "before " << A->velocity.x << " " << A->velocity.y << std::endl;

	int change;

	if (B->massInv == 0 && A->velocity.x != 0) {
		change = A->velocity.x / abs(A->velocity.x);
	}

	A->velocity -= A->massInv * frictionimpulse;
	B->velocity += B->massInv * frictionimpulseb;

	if (B->massInv == 0 && A->velocity.x != 0) {
		if (change != A->velocity.x / abs(A->velocity.x)) {
			//A->velocity.x -= A->massInv * frictionimpulse.x * 20.0f;
		}
	}

	//std::cout << "after " << A->velocity.x << " " << A->velocity.y << std::endl;


}

void positionalCorrection(bodyPair* pair) {

	RigidBody* A = pair->A;
	RigidBody* B = pair->B;

	const float percent = 0.8; // usually 20% to 80%
	const float slop = 0.01;// usually 0.01 to 0.1
	float correctionFloat = std::max(pair->penetration - slop, 0.0f) / (A->massInv + B->massInv);
	Vector2f correction = correctionFloat * pair->normal;

	A->origin += A->massInv * correction;
	B->origin -= B->massInv * correction;


	//m->A->body->position.x += m->A->massInv * correction.x;
	//m->A->body->position.y += m->A->massInv * correction.y;
	//m->B->body->position.x -= m->B->massInv * correction.x;
	//m->B->body->position.y -= m->B->massInv * correction.y;
}

bool BiasGreaterThan(float a, float b)
{
	const float k_biasRelative = 0.95f;
	const float k_biasAbsolute = 0.01f;
	return a >= b * k_biasRelative + a * k_biasAbsolute;
}

void FindIncidentFace(Vector2f *v, RigidBody* RefPoly, RigidBody* IncPoly, int referenceIndex)
{
	Vector2f referenceNormal = RefPoly->body->normals[referenceIndex];

	// Calculate normal in incident's frame of reference
	//referenceNormal = RefPoly->u * referenceNormal; // To world space
	//referenceNormal = IncPoly->u.Transpose() * referenceNormal; // To incident's model space

	// Find most anti-normal face on incident polygon
	int incidentFace = 0;
	float minDot = FLT_MAX;
	for (int i = 0; i < IncPoly->body->vertexCount; ++i)
	{
		float dot = dotProduct(referenceNormal, IncPoly->body->normals[i]);
		if (dot < minDot)
		{
			minDot = dot;
			incidentFace = i;
		}
	}

	// Assign face vertices for incidentFace
	v[0] = IncPoly->body->vertices[incidentFace];// +IncPoly->body->position;
	incidentFace = incidentFace + 1 >= IncPoly->body->vertexCount ? 0 : incidentFace + 1;
	v[1] = IncPoly->body->vertices[incidentFace];// +IncPoly->body->position;
}

int Clip(Vector2f n, float c, Vector2f *face)
{
	int sp = 0;
	Vector2f out[2] = {
		face[0],
		face[1]
	};

	// Retrieve distances from each endpoint to the line
	// d = ax + by - c
	float d1 = dotProduct(n, face[0]) - c;
	float d2 = dotProduct(n, face[1]) - c;

	// If negative (behind plane) clip
	if (d1 <= 0.0f) out[sp++] = face[0];
	if (d2 <= 0.0f) out[sp++] = face[1];

	// If the points are on different sides of the plane
	if (d1 * d2 < 0.0f) // less than to ignore -0.0f
	{
		// Push interesection point
		float alpha = d1 / (d1 - d2);
		out[sp] = face[0] + alpha * (face[1] - face[0]);
		//out[sp] = Vec2D(face[0].x + alpha * (face[1].x - face[0].x), face[0].y + alpha * (face[1].y - face[0].y));
		++sp;
	}

	// Assign our new converted values
	face[0] = out[0];
	face[1] = out[1];

	return sp;
}

